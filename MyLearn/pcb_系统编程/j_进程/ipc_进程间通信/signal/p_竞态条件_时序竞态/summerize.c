pause函数{
	主动挂起，放弃cpu资源，等待信号唤醒，任意信号
	int pause(void);// 返回-1 设置errno为EINTR
	返回值{
		1.如果默认动作是终止进程，则进程终止，pause没有机会返回
		2.如果默认动作是忽略，进程继续处于挂起状态，pause不返回
		3.如果处理动作是捕捉，则调用完处理函数,在处理函数返回后，返回-1，errno设为EINTR表示信号中断，就可以perror
		4.puse收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒
		等不到就一直等，想要pause后不退出，就捕捉信号
	}

}

时序竞态{
	导例：设个10分钟闹钟，睡一觉
	正常：定时、睡觉、叫醒
	异常：定时、被人叫出去了、  (20分钟后)  回来继续睡，闹钟过了不会再叫我了
		mysleep中设个短的闹钟，在pause之前，失去了超过闹钟时间的cpu资源时间，pause之前要处理alarm信号->捕捉(啥也没干)
		继续pause，就一直挂起了。虽然极端，但是mysleep一直执行，N次后总会出现一次，出现就是致命的
	处理方式{
		可通过屏蔽与解除屏蔽信号来处理，但是不论怎么样，都可能在中途失去cpu，所以：
		先屏蔽  将解除屏蔽和pause绑定在一起，一起执行，就不会在中间失去cpu，让cpu回来后先把信号处理了
		sigsuspend函数{
			具有绑定的功能，在时序要求严格的时候都应该用这个替代pause。//系统调用，都是原子操作，要么不执行，要么执行完
			int sigsuspend(const sigset_t* mask);  //挂起等待信号，和pause相似
			函数调用期间进程信号屏蔽字由这个mask决定 
			//将信号从临时信号屏蔽字mask中删除掉，在调用sigsuspend时就解除屏蔽了，当sigsuspend返回时进程的mask又恢复
			//如果原来的mask是屏蔽，那么返回后仍是屏蔽
			//总是返回-1 ，设定errno-> EINTR
		}
	竟态条件和系统负载有很大关系，负载越严重，信号越不可靠，会出现时序混乱，因为是通过软件实现的
	这种意外只能在程序编写过程中提前预见。否则通过gdb等方式很难找出原因。可能1000万次才出现一次，根本不知道由来。

	}		
}
