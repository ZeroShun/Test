协议--------------------------------------------
	双方商量好的传输规则

网络应用程序模式--------------------------------
	C/S  client/server  
		--优点：1.协议灵活，可自定义，2.数据可提前缓存(游戏动画)
		--缺点：1.对用户安全构成威胁，2.开发任务量大，调试困难
	B/S  browser/server //b row ser
		--优点：1.相较于cs模式安全性更高，2.开发任务小(省约1/3)，3.跨平台
		--缺点：1.必需支持http协议，不可修改协议，必需完全支持。2.数据不可提前缓存 
	使用场景：  数据量大，稳定性高
				数据量小，访问工作量小

分层模型----------------------------------------
	OSI七层：        TCP/IP四层模型：
		应用层             应用层-----   FTP SSH HTTP...    我要做一件什么事
		表示层                       -
		会话层					------
		传输层             传输层        TCP/UDP            做这件事选用哪种连接方式(可靠/不可靠)
		网络层             网络层        IP					封装成ip包，路由器才会识别和转发到目的地去
		数据链路层         网络接口层-						封装成帧，才能进行差错检测
		物理层                       -						传输--
端口号：一个端口号就对应一个进程，指定了端口号就可以传输给指定进程
应用层：最接近用户的协议，我们直接写HTTP之类协议的内容，操作系统自动向下转发


数据包的封装------------------------------------
	帧头 IP数据报头 TCP段首 应用层协议头(---------)帧尾   --->
	封装是操作系统完成的，从网卡出去，经过路由器转发，数据要传输必须封装
	B再逐层解包
//对数据的称呼-> 比特流 帧  ip数据报 段  


通信过程----------------------------------------
	TCP/IP协议通信过程：
FTP协议  应用层   FTP客户<----------->FTP服务器        用户
TCP协议  传输层   TCP<--------------->TCP              内核
IP协议   网络层   IP<---------------->IP                --
以太网协议 链路层 以太网驱动程序<---->以太网驱动程序    --
         物理层   ----------传输---------------         --
TCP建立了连接后，所以的数据都沿固定路由转发，稳定
UDP每次都随机选择路由转发，不稳定
//每一层都不止一个协议，可以自定义、更换


以太网帧格式------------------------------------
	目的地址 源地址 类型 (---------------) CRC     MAC(硬件地址，网卡编号，唯一)
	   MAC	     //0800数据       数据
     下一跳		//0806ARP请求下一跳地址 PAD
				//0835RARP              PAD


ARP数据报---------------------------------------//由已知ip广播，获得mac地址，以转发自己的数据包
	目的地址 源地址 类型 (-----------------------------------) PAD
					//0806									 //填充
					      发送端mac 发送端ip 接收端mac 接收端ip
	  填充f    我的         我的      我的  未知填充f  下一跳ip       在网络中广播
	接收者如果ip对不上，抛弃。如果对得上---->改变信息回发到网络中(填充了自己的mac)
	接收者如果ip对不上，抛弃。如果对得上---->就知道了想要的人的mac地址
帧里面的源和目的ip mac都是指的转发者和下一跳的，ip报里面的是最初的和最终的


路由器转发--------------------------------------	
	发送方全封装
	路由器中，解到网络层，知道了最终的ip ---->  路由选择协议确定下一跳----->封装下一跳mac(没有就arp)--->转发---->
	接收方全解包							x//静态路由的下一跳地址已经设好，根据目标网段自动选择下一跳
											//动态路由通过OSPF等路由选择协议自动寻路，原理复杂
											//通过arp获取下一跳的mac地址，获取过的mac地址会存在路由表中，以供下次使用
	
TTL----------------------------------------------
	//在IP层的IP报头里8位，最多256跳
	//防止拥塞，去目的地的线路断开了，一直在网络中转圈。
	数据包在网络中存在的最长生命周期，以每一跳为单位，初值假设100，经过一个路由器减1，减到0，就抛弃


IP-----------------------------------------------
	... ... ..生存时间...
	32位源ip地址
	32位目的ip地址 8 8 8 8
	...


UDP----------------------------------------------
	16位源端口号   16位目的端口号     //端口号对应进程，通过端口号识别进程
	16位UDP长度    16位UDP检验合
	-------------数据 -----------


TCP----------------------------------------------
	16位源端口号   16位目的端口号     //端口号对应进程，通过端口号识别进程
	32位序号
	4首部长度 6保留 URG ACK PSH PST SYN FIN 16窗口大小
	16检验合       16紧急指针
	选项---
	数据---


应用层(没有固定格式了，用户定义)------------------
	//运用下面的多层来实现自己想实现的功能


NAT映射-------------------------------------------
	正常的我们看到的ip只是在局域网中使用的私有ip地址192.168.1.35
	//路由器中还有一个NAT映射表，描述了局域网和公网的关系
	路由器的公网ip是唯一的
	第一个路由器的映射表：
			//我们的ip      //路由器完成映射成公网
		192.168.1.35：8000---->123.24.56.78：10000//路由器的公网ip，端口号能确定转发给哪一个局域网用户
		192.168.1.25：8000---->123.24.56.78：10001
		192.168.1.55：8000---->123.24.56.78：10002
		//后续的路由器就认为是123.发出来的
		//这就是为什么我们ip这么少，还能全国人都上网，只要公网ip够就行了
//如：我向新浪服务器(公网ip)发送请求，经路由器NAT映射，新浪就认为是123.这个路由器发的，转发给路由器
//路由器再通过映射表转发给我


打洞机制-------------------------------------------
	A------------------腾讯服务器-------------B
	//这样转手，QQ聊天还好，视频聊天就不现实了 既不能实时又浪费资源 视频时直接让AB相连就好了
	//但是直接通过路由器连到对方，路由器会屏蔽陌生ip第一次发的数据包，保护用户
	//当通过服务器qq聊天时，A登录时，将携带自己ip的数据包传送到了腾讯服务器，腾讯服务器回复携带腾讯公dd网ip的数据包给A
		//所以从A到腾讯之间的路由器都不陌生了，同理B也是
	//视频聊天时，腾讯通过公网ip帮双方打洞，把A的ip发给B，B就不会再对A陌生了，同理...然后就可以直连了
公-公：直接访问
公-私：NAT映射  (私-公) 
私-私：打洞
局域网内，随便访问


TCP三次握手----------------------------------------
//网络层不稳定，与硬件联系紧密
传输层：1.完全不弥补---UDP//无连接的不可靠报文传输/单向传递  每次经过的路由器基本不同
		2.完全弥补---TCP//面向连接的可靠数据包传递  每次经过的路由器相同，连接建立 

TCP:
client                            server
//连接(connect accept连接过程)
------------SYN 1000(0)---------->  //SYN请求号、括号里面是数据大小，ACK同意号(对方的SYN+1,SYN+1以前的数据我都收到了)
      <-----SYN 8000, ACK 1001----------
----------------------ACK 8001---> // (三次握手完成)，如：打电话时接电话先喂，对方没喂->网出问题，对方喂->ok 
//传输
------------1001(20) ACK 8001----> //ACK上次的再次应答
	  <-----8001(10) ACK 1021---------- //ACK加上20字节数据
---------------------ACK 8011---->//ACK加上10字节数据
//半关闭(四次握手)--打电话我的事说完了，你继续说--我只能听
------------FIN 1021(0) ACK 8011->//客户端请求断开，仍然可接收
      <-----------------ACK 1022-------//允许你关闭，半关闭状态
	  <-----FIN 8011(0) ACK 2022-------//服务器要求断开
------------------------ACK 8012->//(4次握手完成)，全关闭状态
//以太网帧协议的大小是设计得合适的，数据大了分成小块传。
//丢了一个包，重传问题也不大，没事。如果帧设计得很大，重传很麻烦。
//TCP不是不丢包，是丢了会重传，UDP丢了不重传
四次：linux允许半关闭状态。
MTU 最大传输单元
mss 最大报文段长度，受限于MTU
滑动窗口 win 流量控制(防止对方发送过快，我处理速度慢，缓冲区大小有限)
//都是数据报里面有的


检测是否断开连接:
1.
//一个应用层协议
心跳包----------------------------------------------
//客户端信号不好服务器怎么知道断开了?
服务器过固定时间向客户端发一段数据，收到客户端的回复则正常
如果商量好了，发了多少个包都没回复，就断开连接了
2.
//应用层协议
乒乓包------------------------------------------------
和心跳包差不多，可以携带简单数据
//微信朋友圈，过一会给服务器发一个包，如果有了消息，它给我填充一个小红点回复给我，不需要再建立连接
//如果有了，再建立连接，点开内容--->三次握手
3.设置TCP协议----------------------------------------
发一个探测分节 //很久以前做的，对方必须马.上回给我。没响应就发8个过去(每两个间隔75s)， 一共持续2小时多
般不用，如果要用，要用setsockopt设置一 下

