线程池--------------------------------------------------------------------------------------------------------------------------
//前面在说右边的select poll epoll怎样复用IO，现在说左边创建多线程
	如果来一个再创建一个线程，当CPU负载过高，可能创建不过来，影响与客户端的通信
	所以一次创建一堆线程(逻辑上的池)，

生产者：server  消费者：线程池
 1.维护一个任务队列(加锁) //用条件变量 (任务队列不为空、任务队列不为满)
 2.先最小维护多少个线程(闲着等活) pthread_cond_wait(任务队列不为空) 阻塞等待条件变量满足
 3.当有任务时，'管理者线程'通知线程池       //pthread_signal() 叫醒一个   pthread_broadcast()  叫醒多个
 4.当满了后，server  pthread_cond_wait(任务队列不为满) 阻塞等待
 5.某个线程拿走一个任务后，pthreaad_signal 叫醒 管理者线程


//管理者线程建立线程删除线程的依据

min_thr_num = 10;  //最小线程数
max_thr_num = 100;  //最多--

default_step = 10;  //默认增加减少步长

live_thr_num = 10;  //存活线程数
busy_thr_num = 8;  //干活的线程数


