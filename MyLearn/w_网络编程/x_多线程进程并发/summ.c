//内存开销大，可能最多几百个客户端连接，线程就不能再创建了。进程也差不多。
//多进程和多线程差别不大，多线程可能要小些。这样很靠cpu。cpu得快速切换到对应交互的客户端上，从一个进程到另一个
//所以多线程多进程只适用于连接的客户端比较小的情况下。
多进程：


父进程揽活(while)，来一个client，我就fork子进程，子进程继承cfd，去通信。
	子进程close(lfd)  父进程close(cfd)
	但是client关闭联接，子进程read = 0 子进程退出就变成了僵尸进程。父进程主线程在while没空，并且子进程只能由父进程回收
	1.父进程注册一个SIGCHLD信号捕捉，负责回收子进程，回收了继续揽活
		while(waitpid(0, NULL, WNOHANG) > 0);//非阻塞，应对同时多个进程退出连接(只接收到一次信号,处理期间不接收信号)：
			//处理完一个后，再次进入，如果有，处理了再次进入，如果没有，返回0，退出
	2.开个进程揽活，自己回收子进程
	//子进程关闭lfd，父进程关闭cfd
	read = 0 socket pipe :对端关闭


多线程：
	多用pthread_detach分离线程
	用结构体传参

//在进程同步时，也用结构体装数据，并把锁装在里面，并内存映射。   两个进程都可以访问到同一把锁，才能同步。
	//管道 fifo 自带阻塞，不需同步
	//信号 不需要同步
	//共读文件 用文件锁 fcntl
	//内存映射 -----------------------> mutex锁、sem信号量

//全局变量的异步io问题：当信号来的时候，我在处理函数里面改了全局变量，然后又改了全局变量，不能进入If语句
	//在中断处理函数里面加把锁：锁修改falg的语句   
	//主进程也加这个锁：将给对方发信号的语句和下面的flag修改语句锁起来
	//发信号--->失去cpu---->处理函数想改flag发现被锁了，等待---->主进程把flag修改完了解锁---->处理函数修改flag
	//这样，就能正常进入if语句了
	//锁能用于进程同步，也能用于进程内的全局变量的保护。锁本来就是用来保护共享区的。内存映射就是共享区，保护！
